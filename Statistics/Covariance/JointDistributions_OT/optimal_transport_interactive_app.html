<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimal Transport Playground</title>
    <style>
        :root {
            --bg-color: #f4f4f9;
            --panel-bg: #ffffff;
            --primary: #4a7298;
            --primary-light: #6a9ac4;
            --accent: #2c3e50;
            --text: #333;
            --source-color: #2980b9;
            --target-color: #c0392b;
            --border: #e0e0e0;
            --danger: #e74c3c;
            --danger-hover: #c0392b;
            --success: #27ae60;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background: var(--accent);
            color: white;
            padding: 0.7rem 1rem;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        h1 { margin: 0; font-size: 1.1rem; font-weight: 400; letter-spacing: 0.3px; }

        /* Main layout: left panel | center viz | right panel */
        .main-row {
            display: flex;
            flex: 1;
            overflow: hidden;
            min-height: 0;
        }

        /* Side panels for distributions */
        .side-panel {
            width: 280px;
            background: var(--panel-bg);
            padding: 10px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-shrink: 0;
        }
        .side-panel.left {
            border-right: 1px solid var(--border);
        }
        .side-panel.right {
            border-left: 1px solid var(--border);
        }

        .control-group {
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            background: #fafafa;
        }
        .control-group h3 {
            margin-top: 0;
            font-size: 0.85rem;
            color: var(--accent);
            border-bottom: 2px solid var(--border);
            padding-bottom: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .control-group h3 .color-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
            vertical-align: middle;
        }

        .slider-row {
            margin-bottom: 8px;
        }
        .slider-row label {
            display: flex;
            justify-content: space-between;
            font-size: 0.78rem;
            margin-bottom: 2px;
            color: #555;
        }
        .slider-row label span {
            font-weight: 600;
            color: var(--accent);
            min-width: 35px;
            text-align: right;
        }
        input[type=range] {
            width: 100%;
            cursor: pointer;
            height: 16px;
        }

        /* Mode card styling */
        .mode-card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 10px;
            margin-bottom: 8px;
            position: relative;
        }
        .mode-card .mode-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .mode-card .mode-label {
            font-size: 0.78rem;
            font-weight: 600;
            color: #666;
        }
        .mode-card .remove-mode {
            background: none;
            border: 1px solid var(--danger);
            color: var(--danger);
            cursor: pointer;
            font-size: 0.7rem;
            padding: 1px 6px;
            border-radius: 4px;
            line-height: 1.4;
            transition: all 0.15s;
        }
        .mode-card .remove-mode:hover {
            background: var(--danger);
            color: white;
        }

        .add-mode-btn {
            width: 100%;
            padding: 6px 0;
            border: 2px dashed #ccc;
            border-radius: 6px;
            background: none;
            color: #888;
            cursor: pointer;
            font-size: 0.78rem;
            transition: all 0.15s;
        }
        .add-mode-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
            background: rgba(74, 114, 152, 0.05);
        }

        /* Center column: viz + bottom controls */
        .center-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow: hidden;
        }

        /* Visualization Area */
        .viz-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 12px;
            background: var(--bg-color);
            position: relative;
            min-width: 0;
            min-height: 0;
        }
        .plot-container {
            display: grid;
            grid-template-columns: 3fr 1fr;
            grid-template-rows: 1fr 3fr;
            gap: 6px;
            width: min(600px, calc(100% - 20px));
            aspect-ratio: 1;
            max-height: calc(100% - 10px);
            background: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        /* Grid Cells */
        #plot-top { grid-column: 1; grid-row: 1; position: relative; overflow: hidden; }
        #plot-right { grid-column: 2; grid-row: 2; position: relative; overflow: hidden; }
        #plot-main { grid-column: 1; grid-row: 2; position: relative; cursor: crosshair; overflow: hidden; border: 1px solid #eee; }
        #plot-info { grid-column: 2; grid-row: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.7rem; color: #888; text-align: center; padding: 4px; }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.72rem;
            pointer-events: none;
            display: none;
            z-index: 10;
            white-space: nowrap;
        }

        /* Info panel */
        #cost-display {
            font-size: 0.68rem;
            font-weight: 600;
            color: var(--accent);
        }
        #iter-display {
            font-size: 0.62rem;
            color: #aaa;
            margin-top: 2px;
        }

        /* Bottom controls strip */
        .bottom-controls {
            background: var(--panel-bg);
            border-top: 1px solid var(--border);
            padding: 8px 16px;
            display: flex;
            gap: 16px;
            align-items: flex-start;
            flex-shrink: 0;
            flex-wrap: wrap;
        }
        .bottom-controls .control-group {
            flex: 1;
            min-width: 180px;
            margin: 0;
        }
        .bottom-controls .control-group h3 {
            font-size: 0.8rem;
            margin-bottom: 6px;
            padding-bottom: 4px;
        }

        /* Presets */
        .presets-row {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        .preset-btn {
            flex: 1;
            min-width: 55px;
            padding: 4px 6px;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: white;
            cursor: pointer;
            color: #555;
            transition: all 0.15s;
        }
        .preset-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
            background: rgba(74, 114, 152, 0.05);
        }

        .desc-text {
            font-size: 0.72rem;
            color: #666;
            margin: 2px 0 4px 0;
        }

        /* Cost function select */
        .cost-select {
            width: 100%;
            padding: 4px 6px;
            font-size: 0.78rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: white;
            color: var(--text);
            cursor: pointer;
            margin-bottom: 4px;
        }

        /* Scrollbar styling */
        .side-panel::-webkit-scrollbar { width: 6px; }
        .side-panel::-webkit-scrollbar-track { background: #f0f0f0; }
        .side-panel::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
        .side-panel::-webkit-scrollbar-thumb:hover { background: #aaa; }
    </style>
</head>
<body>

<header>
    <h1>Optimal Transport: Kantorovich Plan Visualiser</h1>
</header>

<div class="main-row">
    <!-- Left Panel: Source Distribution -->
    <div class="side-panel left" id="source-panel">
        <div class="control-group" id="source-group">
            <h3>
                <span><span class="color-dot" style="background:var(--source-color)"></span>Source (Top)</span>
            </h3>
            <p class="desc-text">The starting pile of "dirt".</p>
            <div id="source-modes"></div>
            <button class="add-mode-btn" id="add-source-mode">+ Add Mode</button>
        </div>
    </div>

    <!-- Center: Visualization + Bottom Controls -->
    <div class="center-column">
        <div class="viz-area">
            <div class="plot-container">
                <div id="plot-top">
                    <canvas id="canvas-top"></canvas>
                </div>
                <div id="plot-info">
                    <div id="cost-display">Cost: --</div>
                    <div id="iter-display"></div>
                </div>
                <div id="plot-main">
                    <canvas id="canvas-main"></canvas>
                    <div id="tooltip" class="tooltip"></div>
                </div>
                <div id="plot-right">
                    <canvas id="canvas-right"></canvas>
                </div>
            </div>
        </div>

        <!-- Bottom Controls -->
        <div class="bottom-controls">
            <!-- Presets -->
            <div class="control-group">
                <h3>Presets</h3>
                <div class="presets-row" id="presets-row"></div>
            </div>

            <!-- Ground Cost -->
            <div class="control-group">
                <h3>Ground Cost</h3>
                <select class="cost-select" id="cost-function">
                    <option value="squared_euclidean">Squared Euclidean |x-y|&sup2;</option>
                    <option value="euclidean">Euclidean |x-y|</option>
                    <option value="quartic">Quartic |x-y|&sup4;</option>
                    <option value="huber">Huber (delta=1)</option>
                    <option value="log_cosh">Log-Cosh</option>
                </select>
                <p class="desc-text" id="cost-desc">Standard squared distance ground cost.</p>
            </div>

            <!-- Algorithm -->
            <div class="control-group">
                <h3>Algorithm</h3>
                <div class="slider-row">
                    <label>Regularisation (&epsilon;) <span id="val-reg">0.100</span></label>
                    <input type="range" id="reg" min="0.005" max="1.0" step="0.005" value="0.10">
                </div>
                <div class="slider-row">
                    <label>Grid Resolution <span id="val-res">64</span></label>
                    <input type="range" id="res" min="24" max="512" step="4" value="64">
                </div>
            </div>

            <!-- How to read -->
            <div class="control-group" style="flex: 1.5;">
                <h3>How to Read</h3>
                <p class="desc-text" style="margin:0;">
                    The heatmap shows the optimal transport plan &gamma;(x, y).
                    Bright spots at (x, y) mean mass moves from position x in the source
                    to position y in the target. Side plots show the marginals.
                </p>
            </div>
        </div>
    </div>

    <!-- Right Panel: Target Distribution -->
    <div class="side-panel right" id="target-panel">
        <div class="control-group" id="target-group">
            <h3>
                <span><span class="color-dot" style="background:var(--target-color)"></span>Target (Right)</span>
            </h3>
            <p class="desc-text">Where the dirt needs to go.</p>
            <div id="target-modes"></div>
            <button class="add-mode-btn" id="add-target-mode">+ Add Mode</button>
        </div>
    </div>
</div>

<script>
/**
 * Optimal Transport Visualiser — Log-domain Sinkhorn
 *
 * Features:
 *   - Log-domain Sinkhorn iterations for numerical stability at low epsilon
 *   - Dynamic modes: add / remove any number of Gaussian components per distribution
 *   - Per-mode variance (standard deviation) control
 *   - Viridis-inspired colormap
 *   - Transport cost and convergence display
 *   - Preset configurations
 *   - Adjustable grid resolution (up to 512)
 *   - Multiple ground cost / distance functions
 *   - Three-column layout: source (left) | viz + controls (center) | target (right)
 */

// ──────────────────────────────────────────────
//  Configuration
// ──────────────────────────────────────────────
let N = 64;               // grid resolution (adjustable up to 512)
const LIMIT = 5.0;        // domain [-LIMIT, LIMIT]
const MAX_ITER = 300;      // max Sinkhorn iterations
const TOL = 1e-6;         // convergence tolerance on marginal error

// ──────────────────────────────────────────────
//  State
// ──────────────────────────────────────────────
const state = {
    source: [
        { mean: -2.0, std: 0.8, weight: 1.0 }
    ],
    target: [
        { mean: -2.0, std: 0.8, weight: 0.6 },
        { mean:  2.5, std: 0.8, weight: 0.4 }
    ],
    reg: 0.10,
    costFunction: 'squared_euclidean'
};

// ──────────────────────────────────────────────
//  DOM references
// ──────────────────────────────────────────────
const canvasMain  = document.getElementById('canvas-main');
const canvasTop   = document.getElementById('canvas-top');
const canvasRight = document.getElementById('canvas-right');
const tooltip     = document.getElementById('tooltip');
const costDisplay = document.getElementById('cost-display');
const iterDisplay = document.getElementById('iter-display');

// ──────────────────────────────────────────────
//  Ground cost / distance functions
// ──────────────────────────────────────────────
const COST_FUNCTIONS = {
    squared_euclidean: {
        label: 'Squared Euclidean |x-y|²',
        desc: 'Standard squared distance ground cost.',
        fn: (d) => d * d
    },
    euclidean: {
        label: 'Euclidean |x-y|',
        desc: 'Absolute distance. Produces sharper, more localised plans.',
        fn: (d) => Math.abs(d)
    },
    quartic: {
        label: 'Quartic |x-y|⁴',
        desc: 'Fourth-power cost. Heavily penalises long-range transport.',
        fn: (d) => d * d * d * d
    },
    huber: {
        label: 'Huber (delta=1)',
        desc: 'Quadratic near zero, linear far away. Robust to outliers.',
        fn: (d) => {
            const a = Math.abs(d);
            return a <= 1.0 ? 0.5 * d * d : a - 0.5;
        }
    },
    log_cosh: {
        label: 'Log-Cosh',
        desc: 'Smooth approximation to absolute value. log(cosh(x)).',
        fn: (d) => Math.log(Math.cosh(d))
    }
};

document.getElementById('cost-function').addEventListener('change', (e) => {
    state.costFunction = e.target.value;
    document.getElementById('cost-desc').textContent = COST_FUNCTIONS[state.costFunction].desc;
    scheduleUpdate();
});

// ──────────────────────────────────────────────
//  Viridis-inspired colormap (256 entries)
// ──────────────────────────────────────────────
const VIRIDIS = buildViridis();

function buildViridis() {
    const stops = [
        [0.0,   [253, 253, 253]],
        [0.01,  [68,   1,  84]],
        [0.15,  [72,  36, 117]],
        [0.30,  [56,  88, 140]],
        [0.45,  [39, 130, 142]],
        [0.60,  [31, 158, 137]],
        [0.75,  [78, 195, 107]],
        [0.90,  [170, 220,  50]],
        [1.0,   [253, 231,  37]]
    ];
    const map = new Array(256);
    for (let i = 0; i < 256; i++) {
        const t = i / 255;
        let lo = stops[0], hi = stops[stops.length - 1];
        for (let s = 0; s < stops.length - 1; s++) {
            if (t >= stops[s][0] && t <= stops[s + 1][0]) {
                lo = stops[s];
                hi = stops[s + 1];
                break;
            }
        }
        const frac = (hi[0] === lo[0]) ? 0 : (t - lo[0]) / (hi[0] - lo[0]);
        map[i] = [
            Math.round(lo[1][0] + (hi[1][0] - lo[1][0]) * frac),
            Math.round(lo[1][1] + (hi[1][1] - lo[1][1]) * frac),
            Math.round(lo[1][2] + (hi[1][2] - lo[1][2]) * frac)
        ];
    }
    return map;
}

// ──────────────────────────────────────────────
//  Math helpers
// ──────────────────────────────────────────────
function gaussian(x, mean, std) {
    const z = (x - mean) / std;
    return Math.exp(-0.5 * z * z) / (std * Math.sqrt(2 * Math.PI));
}

function buildDistribution(coords, modes) {
    const n = coords.length;
    const dist = new Float64Array(n);
    let sum = 0;

    for (let i = 0; i < n; i++) {
        let val = 0;
        for (const m of modes) {
            if (m.weight > 0) {
                val += m.weight * gaussian(coords[i], m.mean, m.std);
            }
        }
        dist[i] = val;
        sum += val;
    }

    const eps = 1e-10;
    if (sum < eps) {
        const u = 1 / n;
        for (let i = 0; i < n; i++) dist[i] = u;
    } else {
        for (let i = 0; i < n; i++) dist[i] = dist[i] / sum;
    }

    let resum = 0;
    for (let i = 0; i < n; i++) {
        dist[i] = Math.max(dist[i], eps);
        resum += dist[i];
    }
    for (let i = 0; i < n; i++) dist[i] /= resum;

    return dist;
}

// ──────────────────────────────────────────────
//  Log-domain Sinkhorn
// ──────────────────────────────────────────────

function logSumExp(arr) {
    let max = -Infinity;
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] > max) max = arr[i];
    }
    if (!isFinite(max)) return -Infinity;
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
        sum += Math.exp(arr[i] - max);
    }
    return max + Math.log(sum);
}

function solveSinkhornLogDomain(a, b, coords, reg) {
    const n = a.length;
    const costFn = COST_FUNCTIONS[state.costFunction].fn;

    const logA = new Float64Array(n);
    const logB = new Float64Array(n);
    for (let i = 0; i < n; i++) {
        logA[i] = Math.log(a[i]);
        logB[i] = Math.log(b[i]);
    }

    // Cost matrix: -C(x_i, y_j) / reg
    const negC = new Float64Array(n * n);
    // Also store raw cost for total cost computation
    const rawCost = new Float64Array(n * n);
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            const d = coords[i] - coords[j];
            const c = costFn(d);
            rawCost[i * n + j] = c;
            negC[i * n + j] = -c / reg;
        }
    }

    const f = new Float64Array(n);
    const g = new Float64Array(n);

    let convergedIter = MAX_ITER;
    const tmp = new Float64Array(n);

    for (let iter = 0; iter < MAX_ITER; iter++) {
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                tmp[j] = negC[i * n + j] + g[j];
            }
            f[i] = logA[i] - logSumExp(tmp);
        }

        let maxErr = 0;
        for (let j = 0; j < n; j++) {
            for (let i = 0; i < n; i++) {
                tmp[i] = negC[i * n + j] + f[i];
            }
            const newG = logB[j] - logSumExp(tmp);
            const err = Math.abs(newG - g[j]);
            if (err > maxErr) maxErr = err;
            g[j] = newG;
        }

        if (maxErr < TOL) {
            convergedIter = iter + 1;
            break;
        }
    }

    // Recover transport plan
    const gamma = new Float64Array(n * n);
    let maxVal = 0;
    let totalCost = 0;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            const val = Math.exp(f[i] + negC[i * n + j] + g[j]);
            gamma[i * n + j] = val;
            if (val > maxVal) maxVal = val;
            totalCost += val * rawCost[i * n + j];
        }
    }

    return { gamma, maxVal, totalCost, convergedIter, n };
}

// ──────────────────────────────────────────────
//  Drawing
// ──────────────────────────────────────────────

function drawLinePlot(ctx, data, width, height, isVertical, color) {
    ctx.clearRect(0, 0, width, height);

    const maxVal = Math.max(...data) * 1.15;
    if (maxVal === 0) return;

    ctx.beginPath();

    if (!isVertical) {
        ctx.moveTo(0, height);
        for (let i = 0; i < data.length; i++) {
            const x = (i / (data.length - 1)) * width;
            const y = height - (data[i] / maxVal) * height;
            ctx.lineTo(x, y);
        }
        ctx.lineTo(width, height);
    } else {
        ctx.moveTo(0, height);
        for (let i = 0; i < data.length; i++) {
            const y = height - (i / (data.length - 1)) * height;
            const x = (data[i] / maxVal) * width;
            ctx.lineTo(x, y);
        }
        ctx.lineTo(0, 0);
    }

    ctx.fillStyle = color + '30';
    ctx.fill();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawHeatmap(ctx, result, width, height) {
    const n = result.n;
    const gamma = result.gamma;
    const maxVal = result.maxVal;

    ctx.clearRect(0, 0, width, height);

    if (maxVal === 0) return;

    const imgData = ctx.createImageData(n, n);
    const pixels = imgData.data;

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            const val = gamma[i * n + j];
            let intensity = val / (maxVal * 0.85);
            if (intensity > 1) intensity = 1;

            const ci = Math.min(255, Math.round(intensity * 255));
            const rgb = VIRIDIS[ci];

            const row = n - 1 - j;
            const col = i;
            const idx = (row * n + col) * 4;
            pixels[idx]     = rgb[0];
            pixels[idx + 1] = rgb[1];
            pixels[idx + 2] = rgb[2];
            pixels[idx + 3] = 255;
        }
    }

    const offscreen = document.createElement('canvas');
    offscreen.width = n;
    offscreen.height = n;
    offscreen.getContext('2d').putImageData(imgData, 0, 0);

    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(offscreen, 0, 0, width, height);
}

// ──────────────────────────────────────────────
//  Update loop (debounced)
// ──────────────────────────────────────────────
let updatePending = false;

function scheduleUpdate() {
    if (!updatePending) {
        updatePending = true;
        requestAnimationFrame(() => {
            updatePending = false;
            update();
        });
    }
}

function update() {
    const coords = new Float64Array(N);
    for (let i = 0; i < N; i++) {
        coords[i] = -LIMIT + (i / (N - 1)) * (2 * LIMIT);
    }

    const mu = buildDistribution(coords, state.source);
    const nu = buildDistribution(coords, state.target);

    const result = solveSinkhornLogDomain(mu, nu, coords, state.reg);

    costDisplay.textContent = 'Cost: ' + result.totalCost.toFixed(4);
    iterDisplay.textContent = result.convergedIter < MAX_ITER
        ? 'Converged in ' + result.convergedIter + ' iter'
        : MAX_ITER + ' iter (max)';

    const topRect   = document.getElementById('plot-top').getBoundingClientRect();
    const rightRect = document.getElementById('plot-right').getBoundingClientRect();
    const mainRect  = document.getElementById('plot-main').getBoundingClientRect();

    const dpr = window.devicePixelRatio || 1;

    canvasTop.width  = topRect.width * dpr;  canvasTop.height  = topRect.height * dpr;
    canvasRight.width = rightRect.width * dpr; canvasRight.height = rightRect.height * dpr;
    canvasMain.width  = mainRect.width * dpr; canvasMain.height  = mainRect.height * dpr;

    const ctxTop   = canvasTop.getContext('2d');
    const ctxRight = canvasRight.getContext('2d');
    const ctxMain  = canvasMain.getContext('2d');

    ctxTop.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctxRight.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctxMain.setTransform(dpr, 0, 0, dpr, 0, 0);

    drawLinePlot(ctxTop, mu, topRect.width, topRect.height, false, '#2980b9');
    drawLinePlot(ctxRight, nu, rightRect.width, rightRect.height, true, '#c0392b');
    drawHeatmap(ctxMain, result, mainRect.width, mainRect.height);
}

// ──────────────────────────────────────────────
//  Dynamic Mode UI
// ──────────────────────────────────────────────

function createModeSliders(container, modes, side) {
    container.innerHTML = '';

    modes.forEach((mode, idx) => {
        const card = document.createElement('div');
        card.className = 'mode-card';

        const header = document.createElement('div');
        header.className = 'mode-header';

        const label = document.createElement('span');
        label.className = 'mode-label';
        label.textContent = 'Mode ' + (idx + 1);
        header.appendChild(label);

        if (modes.length > 1) {
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-mode';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => {
                modes.splice(idx, 1);
                renderAllModes();
                scheduleUpdate();
            });
            header.appendChild(removeBtn);
        }

        card.appendChild(header);

        // Mean slider
        card.appendChild(makeSlider(
            'Position', mode.mean, -4.5, 4.5, 0.1, 1,
            (v) => { mode.mean = v; scheduleUpdate(); }
        ));

        // Std slider — min lowered to 0.05 for near-Dirac distributions
        card.appendChild(makeSlider(
            'Std Dev', mode.std, 0.05, 3.0, 0.01, 2,
            (v) => { mode.std = v; scheduleUpdate(); }
        ));

        // Weight slider
        card.appendChild(makeSlider(
            'Weight', mode.weight, 0, 2.0, 0.05, 2,
            (v) => { mode.weight = v; scheduleUpdate(); }
        ));

        container.appendChild(card);
    });
}

function makeSlider(labelText, value, min, max, step, decimals, onChange) {
    const row = document.createElement('div');
    row.className = 'slider-row';

    const lbl = document.createElement('label');
    const nameSpan = document.createTextNode(labelText + ' ');
    const valSpan = document.createElement('span');
    valSpan.textContent = value.toFixed(decimals);
    lbl.appendChild(nameSpan);
    lbl.appendChild(valSpan);

    const input = document.createElement('input');
    input.type = 'range';
    input.min = min;
    input.max = max;
    input.step = step;
    input.value = value;
    input.addEventListener('input', (e) => {
        const v = parseFloat(e.target.value);
        valSpan.textContent = v.toFixed(decimals);
        onChange(v);
    });

    row.appendChild(lbl);
    row.appendChild(input);
    return row;
}

function renderAllModes() {
    createModeSliders(document.getElementById('source-modes'), state.source, 'source');
    createModeSliders(document.getElementById('target-modes'), state.target, 'target');
}

// Add-mode buttons
document.getElementById('add-source-mode').addEventListener('click', () => {
    const usedMeans = state.source.map(m => m.mean);
    const newMean = findAvailablePosition(usedMeans);
    state.source.push({ mean: newMean, std: 0.8, weight: 0.5 });
    renderAllModes();
    scheduleUpdate();
});

document.getElementById('add-target-mode').addEventListener('click', () => {
    const usedMeans = state.target.map(m => m.mean);
    const newMean = findAvailablePosition(usedMeans);
    state.target.push({ mean: newMean, std: 0.8, weight: 0.5 });
    renderAllModes();
    scheduleUpdate();
});

function findAvailablePosition(usedMeans) {
    const candidates = [];
    for (let x = -4.0; x <= 4.0; x += 0.5) {
        let minDist = Infinity;
        for (const m of usedMeans) {
            const d = Math.abs(x - m);
            if (d < minDist) minDist = d;
        }
        candidates.push({ x, dist: minDist });
    }
    candidates.sort((a, b) => b.dist - a.dist);
    return candidates[0] ? candidates[0].x : 0;
}

// ──────────────────────────────────────────────
//  Algorithm parameter sliders
// ──────────────────────────────────────────────

document.getElementById('reg').addEventListener('input', (e) => {
    state.reg = parseFloat(e.target.value);
    document.getElementById('val-reg').textContent = state.reg.toFixed(3);
    scheduleUpdate();
});

document.getElementById('res').addEventListener('input', (e) => {
    N = parseInt(e.target.value);
    document.getElementById('val-res').textContent = N;
    scheduleUpdate();
});

// ──────────────────────────────────────────────
//  Tooltip
// ──────────────────────────────────────────────

canvasMain.addEventListener('mousemove', (e) => {
    const rect = canvasMain.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const domainX = -LIMIT + (x / rect.width) * (2 * LIMIT);
    const domainY = -LIMIT + ((rect.height - y) / rect.height) * (2 * LIMIT);

    tooltip.style.display = 'block';
    tooltip.style.left = (x + 12) + 'px';
    tooltip.style.top = (y - 24) + 'px';
    tooltip.textContent = 'Source: ' + domainX.toFixed(2) + '  Target: ' + domainY.toFixed(2);
});
canvasMain.addEventListener('mouseleave', () => {
    tooltip.style.display = 'none';
});

// ──────────────────────────────────────────────
//  Presets
// ──────────────────────────────────────────────

const PRESETS = {
    'Identity': {
        source: [{ mean: 0, std: 1.0, weight: 1.0 }],
        target: [{ mean: 0, std: 1.0, weight: 1.0 }],
        reg: 0.10,
        desc: 'Same distribution -> diagonal plan'
    },
    'Shift': {
        source: [{ mean: -2, std: 0.8, weight: 1.0 }],
        target: [{ mean: 2, std: 0.8, weight: 1.0 }],
        reg: 0.10,
        desc: 'Simple translation'
    },
    'Split': {
        source: [{ mean: 0, std: 0.6, weight: 1.0 }],
        target: [{ mean: -2.5, std: 0.6, weight: 0.5 }, { mean: 2.5, std: 0.6, weight: 0.5 }],
        reg: 0.08,
        desc: 'One pile splits into two'
    },
    'Merge': {
        source: [{ mean: -2.5, std: 0.6, weight: 0.5 }, { mean: 2.5, std: 0.6, weight: 0.5 }],
        target: [{ mean: 0, std: 0.6, weight: 1.0 }],
        reg: 0.08,
        desc: 'Two piles merge into one'
    },
    'Spread': {
        source: [{ mean: 0, std: 0.4, weight: 1.0 }],
        target: [{ mean: 0, std: 2.0, weight: 1.0 }],
        reg: 0.10,
        desc: 'Narrow to wide — variance change'
    },
    'Multi': {
        source: [{ mean: -3, std: 0.5, weight: 0.33 }, { mean: 0, std: 0.5, weight: 0.33 }, { mean: 3, std: 0.5, weight: 0.33 }],
        target: [{ mean: -1.5, std: 0.7, weight: 0.5 }, { mean: 1.5, std: 0.7, weight: 0.5 }],
        reg: 0.10,
        desc: 'Three modes to two'
    }
};

function applyPreset(name) {
    const p = PRESETS[name];
    if (!p) return;
    state.source = p.source.map(m => ({ ...m }));
    state.target = p.target.map(m => ({ ...m }));
    state.reg = p.reg;

    document.getElementById('reg').value = state.reg;
    document.getElementById('val-reg').textContent = state.reg.toFixed(3);

    renderAllModes();
    scheduleUpdate();
}

function buildPresetButtons() {
    const row = document.getElementById('presets-row');
    for (const name of Object.keys(PRESETS)) {
        const btn = document.createElement('button');
        btn.className = 'preset-btn';
        btn.textContent = name;
        btn.title = PRESETS[name].desc;
        btn.addEventListener('click', () => applyPreset(name));
        row.appendChild(btn);
    }
}

// ──────────────────────────────────────────────
//  Init
// ──────────────────────────────────────────────
buildPresetButtons();
renderAllModes();
window.addEventListener('resize', scheduleUpdate);
scheduleUpdate();

</script>
</body>
</html>
